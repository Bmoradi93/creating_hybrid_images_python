# Creating Hybrid Images - Python Code #
At the very first step, an image filtering function has been developed from scratch accepting an image and a Gaussian filter kernel as its inputs. The second step was to write another function (from scratch again) to generate hybrid images. This function uses the developed image filtering function accepting two relevant images and the Gaussian filter kernel as its inputs. Also, given that a Gaussian filter is provided for us,  but as an interesting part of this repoitory, a faction has been developed to create a Gaussian filter kernel from scratch. This way one is able to simply understand the whole idea behind the provided filter.

### Image Filtering ###
Why we filter images? In this part, I try to answer this question. An image is nothing but a 2D signal and can be modeled mathematically by the f(x, y) function. x and y are the exact locations on each pixel in the image. The output of this function is an uint8 integer value from 0 to 255. So basically, an image is simply a matrix and each element of this matrix has the pixel value stored in it. Having said that there exist 2 image types: one is grayscale and the other is colored. A grayscale image is a 2D matrix and a colored image is a 3D matrix and each dimension of this 3D matrix is one color channel of red, green, and blue. That is why we call it the RGB image. My algorithm will support both grayscale and RGB images as input.

As we discussed, the image is a signal and each signal carries some information in form of frequency. So basically, image processing is a specific sort of Signal Processing. Specifically, dealing with images, we are filtering for the following reasons:
* Reducing the noise
* feature detection (Edge detection specifically)
* Blurring (Low-pass signal filtering)
* Sharpening (High-pass signal filtering)

In this repository, the goal is creating a low-pass filtering algorithm to make an input image clear from its high-frequency signals. The generated low-frequency image will be used to generate the high-frequency image. So that is gonna be incredibly easy. Here are the steps:
* Create a low-pass Gaussian filter
* Use the created filter to generate a blurred(e.g., low-frequency) image
* Use the blurred image to generate a sharpened (e.g., high-frequency) image by subtracting it from its original image

### The Gaussian Filter###
The NxN Gaussian filter can be generated by the Gaussian normal distribution function. this function will receive the element location (x, y) and a standard deviation factor. The output of this function will be the value of the respective (x, y) element inside the filter matrix. Having said that (x, y) can only accept ODD values. The center of the filtering matrix will be considered as (0, 0).

![Selection_210](https://user-images.githubusercontent.com/47978272/147422320-22bca7db-b19b-4a8a-bdf6-75cb5e82ccc5.png)

### Image Padding ###
Image padding is necessary step before starting to filter an image. Image padding is simply adding zero layesr to the image margines. based on filter dimensions (NxN), we need to add int(N/2) zero layes to our input image.

![Selection_211](https://user-images.githubusercontent.com/47978272/147422345-046949c8-21d4-4245-bada-1d9fbaed741f.png)

### Image Filtering ###
my_imfilter() function receives an image and a filter kernel as inputs and provides a filtered image as its output. At the very beginning of the algorithm, the image_padding() function will take care image padding step. Then it will check the image type (e.g., colored or grayscale). Based on the following figure, it starts looping over the image pixel by pixel. 
As it can be seen, the value of pixel number “e“ is calculated by the following dot product of filter and its respective part on the original image. 
my_imfilter() function is developed to generate a low-frequency image from its original one. To extract the high-frequency one, simply we can clear the original image from its low-frequency.

![Selection_212](https://user-images.githubusercontent.com/47978272/147422367-e53833a3-f9fd-489c-9756-6c41b685c886.png)

### Generating Hybrid Image ###
A hybrid image is simply an image with two different interpretations from near and far distances.
considering this scenario:
* Image_1: we generate its low-frequency image and we call it the low-frequency image
* Image_2: we generate its high-frequency image and we call it the high-frequency image
* Hybrid Image = (low-frequency image) + (high-frequency image)

From a near distance: it looks like image_1 && from the far distance, it looks like image_2

### Results ###
#### The Gaussian Filter ####
Dimensions: 29x29 && Standard deviation: 21

![Selection_213](https://user-images.githubusercontent.com/47978272/147424538-11ec49ac-11a2-4cfb-b923-6b917d1ce52c.png)

#### Hybrid Images ####
In this repository the following image pairs have been used to generate 5 hybrid images:

![Selection_214](https://user-images.githubusercontent.com/47978272/147424558-56c9e1c8-372a-43b1-b5b4-7b39b16c6ef7.png)

![Selection_215](https://user-images.githubusercontent.com/47978272/147424630-04d560d3-670b-40e2-8814-4cfa84f8c92e.png)

![Selection_216](https://user-images.githubusercontent.com/47978272/147424645-13bc8056-1e0a-467a-acd1-d07be01ae4f4.png)

![Selection_217](https://user-images.githubusercontent.com/47978272/147424660-593e1b1b-9faf-4d65-8588-ac078d244072.png)

![Selection_218](https://user-images.githubusercontent.com/47978272/147424674-c93d1f1d-0270-4e74-a7bd-e7ff9ce42a4a.png)

![Selection_219](https://user-images.githubusercontent.com/47978272/147424685-09a0c085-f4b9-412f-8d54-a7907cd1de47.png)



### How do I get set up? ###

* 

### Who do I talk to? ###

* Behnam Moradi (behnammoradi026@gmail.com)
